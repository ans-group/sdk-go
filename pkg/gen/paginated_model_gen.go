package main

import (
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
	"text/template"
)

type templateData struct {
	TypeName string
}

var modelTemplate = `
// Paginated{{.TypeName}} represents a paginated collection of {{.TypeName}}
type Paginated{{.TypeName}} struct {
	*connection.PaginatedBase

	Items []{{.TypeName}}
}

// NewPaginated{{.TypeName}} returns a pointer to an initialized Paginated{{.TypeName}} struct
func NewPaginated{{.TypeName}}(getFunc connection.PaginatedGetFunc, parameters connection.APIRequestParameters, pagination connection.APIResponseMetadataPagination, items []{{.TypeName}}) *Paginated{{.TypeName}} {
	return &Paginated{{.TypeName}}{
		Items:         items,
		PaginatedBase: connection.NewPaginatedBase(parameters, pagination, getFunc),
	}
}
`

func main() {
	var flagTypeName string
	var flagDestination string
	var flagPackage string
	flag.StringVar(&flagTypeName, "typename", "", "Name of type, comma separated")
	flag.StringVar(&flagDestination, "destination", "", "Path to destination file")
	flag.StringVar(&flagPackage, "package", "", "Package name")
	flag.Parse()

	var result bytes.Buffer

	result.WriteString(fmt.Sprintf("// Code generated by paginated_model_gen. DO NOT EDIT.\npackage %s\n\nimport \"github.com/ukfast/sdk-go/pkg/connection\"\n", flagPackage))

	for _, typeName := range strings.Split(flagTypeName, ",") {
		d := templateData{
			TypeName: strings.TrimSpace(typeName),
		}
		rendered, err := doTemplate(d)
		checkError(err)

		_, err = result.Write(rendered)
		checkError(err)
	}

	err := ioutil.WriteFile(flagDestination, result.Bytes(), 0644)
	checkError(err)
}

func doTemplate(d templateData) ([]byte, error) {
	tmpl, err := template.New("tmpl").Parse(modelTemplate)
	if err != nil {
		return []byte{}, err
	}

	var result bytes.Buffer

	err = tmpl.Execute(&result, d)
	if err != nil {
		return []byte{}, err
	}

	return result.Bytes(), nil
}

func checkError(err error) {
	if err != nil {
		fmt.Print(err.Error())
		os.Exit(1)
	}
}
